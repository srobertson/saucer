# Ports Architecture

**Feature**: Elm-style ports for bidirectional communication between TEA apps and external systems
**Status**: Implemented

---

## Overview

Ports provide a type-safe, Elm-inspired mechanism for external code to interact with Saucer TEA applications without breaking the pure function boundary. They enable:

- **Incoming ports** (`Sub<Msg>`) - External code sends typed data into the app's event loop
- **Outgoing ports** (`Cmd<Msg>`) - External code subscribes to typed data emitted by the app

**Key principles:**
- Apps remain pure (`init`, `update`, `view` are pure functions)
- External integration happens through the `Runtime`'s ports API
- Each port is a typed function declared in the `.tea.rs` template
- Ports are discovered and generated at build time by the Saucer build system
- Type-safe at compile-time - the build system generates all necessary plumbing

---

## Port Declaration

Ports are declared as functions in your `.tea.rs` template file using the `#[port]` attribute:

```rust
use saucer_core::{Cmd, Sub};

#[derive(Clone, Debug)]
pub enum Msg {
    Increment,
    Set(u32),
}

// Incoming port: External → App
// Returns Sub<Msg> - describes how to convert arguments into a message
#[port]
pub fn increment_port() -> Sub<Msg> {
    Msg::Increment
}

#[port]
pub fn set_count(value: u32) -> Sub<Msg> {
    Msg::Set(value)
}

// Outgoing port: App → External
// Returns Cmd<Msg> - actual implementation generated by build system
#[port]
pub fn outbound_count(_count: u32) -> Cmd<Msg> {
    unreachable!() // Never called - implementation is generated
}
```

### Port Declaration Rules

**Incoming ports** (return `Sub<Msg>`):
- Function signature defines the payload type (arguments)
- Function body constructs the `Msg` to send to the app
- Arguments become the payload that external code sends via `.send()`

**Outgoing ports** (return `Cmd<Msg>`):
- Function signature defines the payload type (arguments)
- Function body should be `unreachable!()` - the build system generates the implementation
- Called from `update()` to emit data to external subscribers

**Port names**:
- Must be unique within the application
- Generated as fields on the `Ports` struct
- Snake_case recommended (like `increment_port`, `outbound_count`)

---

## Build-Time Code Generation

The Saucer build system:

1. **Discovers ports**: Scans `.tea.rs` template files for functions marked with `#[port]`
2. **Determines direction**: Based on return type (`Sub<Msg>` vs `Cmd<Msg>`)
3. **Extracts arguments**: Function parameters become the port payload type
4. **Generates infrastructure**:
   - `Ports` struct with a field for each port
   - `IncomingPortIn` handles for sending data to the app
   - `OutgoingPortOut` handles for subscribing to app output
   - Request enum variants for outgoing ports

### Generated Code Structure

For the ports example above, the build system generates:

```rust
pub struct Ports<SelfMsg, AppMsg> {
    // Incoming ports
    pub increment_port: IncrementPortPortIn<SelfMsg, AppMsg>,
    pub set_count: SetCountPortIn<SelfMsg, AppMsg>,

    // Outgoing ports
    pub outbound_count: OutboundCountPortOut,
}

// Incoming port handle
impl<SelfMsg, AppMsg> IncrementPortPortIn<SelfMsg, AppMsg> {
    pub fn send(&self) {
        // Calls the user's function to construct Msg::Increment
        // Sends the message to the app's event loop
    }
}

impl<SelfMsg, AppMsg> SetCountPortIn<SelfMsg, AppMsg> {
    pub fn send(&self, value: u32) {
        // Calls the user's function to construct Msg::Set(value)
        // Sends the message to the app's event loop
    }
}

// Outgoing port handle
impl OutboundCountPortOut {
    pub fn subscribe<F>(&self, f: F)
    where
        F: Fn(u32) + Send + 'static
    {
        // Register callback to receive outbound_count emissions
    }
}
```

---

## Using Ports at Runtime

### Accessing Ports

The generated `Runtime` has a `ports()` method that returns a cloneable `Ports` handle:

```rust
mod runtime {
    include!(concat!(env!("OUT_DIR"), "/runtime.rs"));
}

use runtime::sync::Runtime;

#[tokio::main]
async fn main() {
    let runtime = Runtime::new(
        app::init,
        app::update,
        app::view,
        saucer_core::no_op_reconciler(),
        saucer_core::tracing_observer(),
    );

    // Get ports handle
    let ports = runtime.ports();

    // Ports can be cloned and shared
    let ports_clone = ports.clone();

    runtime.run().await;
}
```

### Sending to Incoming Ports

External code calls `.send()` on incoming port handles:

```rust
let runtime = Runtime::new(/* ... */);
let ports = runtime.ports();

// No-argument port
ports.increment_port.send();

// Single-argument port
ports.set_count.send(42);

// Multi-argument ports work too
// ports.complex_port.send(arg1, arg2, arg3);

runtime.run().await;
```

**Flow:**
1. External code calls `ports.port_name.send(...)`
2. Port handle calls the user's port function to construct the `Msg`
3. Message is sent to the app's event loop
4. `update()` receives and processes the message normally

### Subscribing to Outgoing Ports

External code registers callbacks using `.subscribe()`:

```rust
let runtime = Runtime::new(/* ... */);
let ports = runtime.ports();

// Subscribe to outgoing port emissions
ports.outbound_count.subscribe(|count: u32| {
    println!("Counter changed to: {}", count);

    // Can do anything: log, save to file, send HTTP request, etc.
});

runtime.run().await;
```

**Flow:**
1. App's `update()` returns command: `outbound_count(model.count)`
2. Runtime dispatches command
3. Port infrastructure extracts payload and calls all subscribers
4. Subscribers execute synchronously with the payload

**Multiple subscribers:**
- Multiple callbacks can be registered
- All subscribers are called when the port emits
- Broadcast semantics (not point-to-point)

---

## Complete Example

### Application Code (src/app.tea.rs)

```rust
use saucer_core::{Cmd, Sub};

pub struct Model {
    pub count: u32,
}

#[derive(Clone, Debug)]
pub enum Msg {
    Increment,
    Decrement,
    Set(u32),
}

// Incoming ports
#[port]
pub fn increment() -> Sub<Msg> {
    Msg::Increment
}

#[port]
pub fn decrement() -> Sub<Msg> {
    Msg::Decrement
}

#[port]
pub fn set_value(value: u32) -> Sub<Msg> {
    Msg::Set(value)
}

// Outgoing port
#[port]
pub fn counter_changed(_value: u32) -> Cmd<Msg> {
    unreachable!()
}

pub fn init() -> (Model, Cmd<Msg>) {
    (Model { count: 0 }, Cmd::none())
}

pub fn update(mut model: Model, msg: Msg) -> (Model, Cmd<Msg>) {
    match msg {
        Msg::Increment => {
            model.count += 1;
        }
        Msg::Decrement => {
            model.count -= 1;
        }
        Msg::Set(v) => {
            model.count = v;
        }
    }

    // Emit current count via outgoing port
    (model, counter_changed(model.count))
}

pub fn view(_model: &Model) -> () {
    ()
}
```

### Host Code (src/main.rs)

```rust
mod runtime {
    include!(concat!(env!("OUT_DIR"), "/runtime.rs"));
}

use runtime::sync::Runtime;
use runtime::my_app::app;
use std::sync::{Arc, Mutex};

#[tokio::main]
async fn main() {
    let runtime = Runtime::new(
        app::init,
        app::update,
        app::view,
        saucer_core::no_op_reconciler(),
        saucer_core::tracing_observer(),
    );

    let ports = runtime.ports();

    // Subscribe to outgoing port
    let seen = Arc::new(Mutex::new(Vec::new()));
    let captured = Arc::clone(&seen);
    ports.counter_changed.subscribe(move |count| {
        println!("Counter: {}", count);
        captured.lock().unwrap().push(count);
    });

    // Send to incoming ports (before or during runtime)
    ports.set_value.send(10);
    ports.increment.send();
    ports.increment.send();
    ports.decrement.send();

    // Could spawn external system
    let ports_clone = ports.clone();
    tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        ports_clone.increment.send();
    });

    runtime.run().await;

    // After runtime completes, check what was emitted
    println!("Emitted values: {:?}", *seen.lock().unwrap());
}
```

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                    External Systems                         │
│  (HTTP handlers, CLI, Background workers, Infrastructure)   │
└─────────────────────────────────────────────────────────────┘
              ↓ .send()                  ↑ .subscribe()
         ┌────────────────────────────────────────┐
         │      runtime.ports() → Ports           │
         │                                        │
         │  Incoming            Outgoing         │
         │  ├─ increment        ├─ counter_changed     │
         │  ├─ decrement        └─ log_message        │
         │  └─ set_value                          │
         └────────────────────────────────────────┘
              ↓ send_to_app       ↑ PortsRequest dispatch
┌─────────────────────────────────────────────────────────────┐
│                     Runtime (Generated)                     │
│                                                             │
│  ┌─────────┐   Msg      ┌─────────┐   Cmd    ┌──────────┐ │
│  │  Model  │ ─────────→ │  update │ ────────→│ Dispatch │ │
│  └─────────┘            └─────────┘          └──────────┘ │
│       ↑                      │                      │      │
│       │                      │                      ↓      │
│       │                 ┌────────┐         PortsRequest   │
│       └─────────────────│  view  │         (outgoing)     │
│                         └────────┘                  │      │
│                              ↓                      │      │
│                         Reconciler ─────────────────┘      │
│                                                             │
│  App: Pure functions (init/update/view)                    │
└─────────────────────────────────────────────────────────────┘
```

---

## Port Payload Types

### No Arguments

```rust
#[port]
pub fn trigger() -> Sub<Msg> {
    Msg::Triggered
}

// Usage:
ports.trigger.send();  // No arguments
```

### Single Argument

```rust
#[port]
pub fn set_name(name: String) -> Sub<Msg> {
    Msg::SetName(name)
}

// Usage:
ports.set_name.send("Alice".to_string());
```

### Multiple Arguments

```rust
#[port]
pub fn create_user(name: String, age: u32, active: bool) -> Sub<Msg> {
    Msg::CreateUser { name, age, active }
}

// Usage:
ports.create_user.send("Bob".to_string(), 30, true);
```

**Payload type mapping:**
- 0 args → `()`
- 1 arg → the argument's type
- N args → tuple `(T1, T2, ..., TN)`

---

## Testing

Ports work in synchronous test harnesses:

```rust
#[test]
fn test_incoming_port() {
    let runtime = mock_app::build_runtime();
    let ports = runtime.ports();

    let seen = Arc::new(Mutex::new(Vec::new()));
    let captured = Arc::clone(&seen);

    // Subscribe to outgoing port
    ports.counter_changed.subscribe(move |count| {
        captured.lock().unwrap().push(count);
    });

    // Send to incoming ports
    ports.set_value.send(10);
    ports.increment.send();
    ports.increment.send();

    // Run the runtime
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_time()
        .build()
        .unwrap();

    rt.block_on(async {
        tokio::time::timeout(
            Duration::from_secs(1),
            runtime.run()
        ).await.unwrap();
    });

    // Verify outgoing port emissions
    assert_eq!(&*seen.lock().unwrap(), &[10, 11, 12]);
}
```

---

## Design Decisions

### Why Function-Based Declaration?

**Alternatives considered:**
1. Attribute on enum variants (`#[port] Increment` in `Msg` enum) - rejected (doesn't work with generated types)
2. Separate macro (`port!`) - rejected (less ergonomic, harder to compose)
3. Functions with `#[port]` attribute - **chosen** (clear, composable, type-safe)

**Benefits:**
- Clear separation: port function vs message constructor
- Easy to understand: "this function converts payload → Msg"
- Composes well with generated code
- Works with Saucer's template transformation system
- Discoverable at build time via AST analysis

### Why Sub<Msg> and Cmd<Msg> Return Types?

**Matches Elm's port semantics:**
- Incoming ports are like subscriptions (`Sub`) - external world → app
- Outgoing ports are like commands (`Cmd`) - app → external world
- Leverages existing Saucer command infrastructure
- Type-safe: can't confuse incoming and outgoing ports

### Why unreachable!() for Outgoing Ports?

The outgoing port function is never actually called - it's a **declaration** of the port's signature. The build system:

1. Parses the function signature to extract payload type
2. Generates a command helper that wraps the payload in a `PortsRequest`
3. Runtime dispatches `PortsRequest` to subscribers

The function body is ignored, so `unreachable!()` makes the intent clear: "this is never executed, implementation is generated."

### Why Synchronous Callbacks?

**Alternative:** Async streams or channels

**Chosen:** Synchronous callbacks

**Rationale:**
- Simpler testing (no async harness complexity)
- Matches Elm's synchronous subscription model
- Subscribers can spawn async work if needed
- Deterministic execution order
- No buffering/backpressure complexity

---

## Limitations and Future Work

### Current Limitations

1. **No dynamic port creation** - Ports must be declared in `.tea.rs` at compile time
2. **No port removal** - Once subscribed, callbacks stay registered for runtime lifetime
3. **No backpressure** - Incoming ports use unbounded channels
4. **Synchronous dispatch** - Outgoing port callbacks block command dispatch

### Future Enhancements

- **Port filtering** - Conditional port routing based on runtime state
- **Port middleware** - Transform payloads before delivery
- **Port metrics** - Built-in observability for port usage
- **Dynamic subscriptions** - Subscribe/unsubscribe during runtime
- **Async subscribers** - Non-blocking callback execution

---

## Migration from Vandura

If you're porting code from Vandura to Saucer:

### Old Vandura Pattern

```rust
// Vandura: Attributes on enum variants
#[derive(Ports)]
pub enum Event {
    #[port(increment)]
    Increment { amount: i32 },
}

declare_effects!(Effect => [
    Time: TimeManager,
], ports => [
    counter_changed: CounterChanged { value: i32 },
]);
```

### New Saucer Pattern

```rust
// Saucer: Functions with #[port] attribute
#[port]
pub fn increment(amount: i32) -> Sub<Msg> {
    Msg::Increment { amount }
}

#[port]
pub fn counter_changed(_value: i32) -> Cmd<Msg> {
    unreachable!()
}
```

**Key differences:**
- No `declare_effects!` macro - ports are just `#[port]` functions
- No `#[derive(Ports)]` - build system discovers ports automatically
- Incoming ports return `Sub<Msg>`, outgoing return `Cmd<Msg>`
- Cleaner, more functional style

---

## References

- **Effect Managers**: [effect-managers.md](effect-managers.md)
- **Commands**: [cmd.md](cmd.md)
- **Observability**: [observability.md](observability.md)
- **Elm Ports**: https://guide.elm-lang.org/interop/ports.html
- **Test Examples**: `crates/saucer/saucer-core/tests/mock_port_app/`
