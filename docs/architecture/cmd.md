# Commands (Cmd)

Reference documentation for Saucer's command pattern - how apps request side effects and receive results.

---

## 1. Overview

**Commands are declarative requests for side effects.** In Saucer's TEA architecture, apps remain pure functions that describe *what* effects should happen, while effect managers handle *how* to execute them.

### Core Concept

The `Cmd` type is the primary mechanism for requesting effects. Apps construct commands using **command helpers** provided by effect managers, specifying:

- What effect to execute (e.g., HTTP request, timer, file I/O)
- What parameters the effect needs (URL, duration, file path)
- How to transform the result into the app's `Msg` type

**Key benefits:**
- **Payload hiding**: Apps work with ergonomic helpers, not raw request structures
- **Type safety**: The build system ensures all commands match the app's `Msg` type
- **Composability**: Commands batch naturally and map through wrapper apps
- **Separation of concerns**: Apps describe effects; managers execute them

### Key Concepts

**Commands hide request payloads** - Apps use ergonomic helpers instead of raw Request constructors. You call `notify_after(...)`, not `Cmd::single(Request::Time(...))`.

**The `returns` callback** - The heart of the system. It's how effect results flow back into the app's `Msg` type. The callback is stored as data and invoked by the manager when the effect completes.

**Just data** - Commands are declarative descriptions, not executable code. Creating a command doesn't execute anything - it describes what should happen.

**Fictional imports** - Templates use `use manager::command::helper` which the build system transforms into generated code. The imports don't exist at the source level; they're markers for code generation.

**Generated helpers** - When applications import crates as dependencies, the build system checks if those crates provide effect managers (via `[package.metadata.saucer]`). For discovered managers, it wraps their request helpers in `Cmd::single(Request::Manager(...))` and makes them available in the shared runtime.

**The `.map()` method** - Composes callbacks to transform intermediate results before wrapping in `Msg`. Allows functional pipelines like `request.map(parse).map(Msg::GotData)`.

---

## 2. The Cmd Type

### Type Alias

```rust
pub type Cmd<Msg> = saucer_core::CoreCmd<Request<Msg>>;
```

**Structure:**
- `Cmd<Msg>` - Public type alias used by apps
- `CoreCmd<T>` - Generic container holding a batch of requests
- `Request<Msg>` - Generated enum wrapping all manager requests + core requests + port requests

### CoreCmd Structure

```rust
pub struct CoreCmd<Req>(pub Vec<Req>);

impl<Req> CoreCmd<Req> {
    /// No-op command - produces no effects
    pub fn none() -> Self { CoreCmd(Vec::new()) }

    /// Single request
    pub fn single(req: Req) -> Self { CoreCmd(vec![req]) }

    /// Batch multiple commands together
    pub fn batch(cmds: impl IntoIterator<Item = CoreCmd<Req>>) -> Self {
        // Flattens all commands into a single Vec
    }
}
```

**Properties:**
- Commands are just data - no execution happens when creating them
- Multiple commands batch efficiently (flat Vec, no nested structures)
- `Cmd::none()` is the identity - safe to return when no effects are needed

---

## 3. How Commands Work

### The Request Enum

The build system generates a `Request<Msg>` enum that wraps all effect manager request types:

```rust
// Generated by build system
#[derive(Clone)]
pub enum Request<Msg> {
    Core(saucer_core::CoreRequest),
    Time(saucer_time_manager::TimeRequest<Msg>),
    Http(saucer_http_manager::HttpRequest<Msg>),
    Ports(PortsRequest, PhantomData<Msg>),
}
```

**Each variant:**
- Wraps a manager-specific request type (e.g., `TimeRequest<Msg>`)
- Includes the app's `Msg` type parameter
- Contains all information needed to execute the effect and route the result back

### Manager Request Types

Effect managers define their own `Request` enums with **returns callbacks**:

```rust
// From saucer_time_manager::requests
#[derive(Clone)]
pub enum TimeRequest<Msg> {
    Now {
        returns: Arc<dyn Fn(f64) -> Msg + Send + Sync>,
    },
    NotifyAfter {
        id: u64,
        duration: Duration,
        returns: Arc<dyn Fn() -> Msg + Send + Sync>,
    },
    // ... other variants
}
```

**Key points:**
- The `returns` field is a function that converts the effect result into `Msg`
- This is **pure data** - the function is stored, not executed
- The manager will invoke this callback when the effect completes
- Different variants can have different return signatures based on what result they produce

### The Flow

```
1. App calls command helper:
   notify_after(0, Duration::from_secs(5), || Msg::TimerExpired)
                                              ^^^^^^^^^^^^^^^^^^^
                                              returns callback

2. Helper creates TimeRequest<Msg>:
   TimeRequest::NotifyAfter {
       id: 0,
       duration: Duration::from_secs(5),
       returns: Arc::new(|| Msg::TimerExpired)
   }

3. Helper wraps in Cmd:
   Cmd::single(Request::Time(time_request))

4. App returns (model, cmd) from update()

5. Runtime dispatches request to TimeManager

6. Manager executes effect (spawns tokio timer)

7. Timer completes, manager invokes callback:
   let msg = (request.returns)();  // => Msg::TimerExpired

8. Manager sends msg to app via router:
   router.send_to_app(msg);

9. App's update() receives Msg::TimerExpired
```

---

## 4. Command Helpers

### What Are Command Helpers?

Command helpers are **generated functions** that provide an ergonomic API for creating commands. They hide the underlying `Request` enum construction from app authors.

**Example helper:**
```rust
// Generated by build system from saucer_time_manager::requests::notify_after
pub fn notify_after<Msg: 'static>(
    id: u64,
    duration: std::time::Duration,
    returns: impl Fn() -> Msg + Send + Sync + 'static,
) -> Cmd<Msg> {
    Cmd::single(Request::Time(
        saucer_time_manager::requests::notify_after(id, duration, returns)
    ))
}
```

**What it does:**
- Takes effect parameters (id, duration)
- Takes a `returns` callback (how to create the app's Msg)
- Creates the manager's request type
- Wraps it in the generated `Request` enum
- Wraps that in `Cmd::single()`
- Returns `Cmd<Msg>` ready to use

### Helper Source

Helpers are generated from **request helpers** defined by effect managers in their `requests.rs` module:

```rust
// In saucer_time_manager/src/requests.rs
pub fn notify_after<Msg: 'static>(
    id: u64,
    duration: Duration,
    returns: impl Fn() -> Msg + Send + Sync + 'static,
) -> TimeRequest<Msg> {
    TimeRequest::NotifyAfter {
        id,
        duration,
        returns: Arc::new(returns),
    }
}
```

**Build system discovery:**
1. Scans application's `Cargo.toml` dependencies
2. Checks each dependency for `[package.metadata.saucer]` with `effect_manager = true`
3. For discovered effect managers, reads helpers from `<manager>/src/requests.rs`
4. For each helper used by templates, generates a wrapped version in the shared runtime
5. Generated helper calls the original, wraps result in `Request::ManagerName(...)`
6. Wraps that in `Cmd::single(...)` and makes it available to templates

### Fictional Imports

Apps use **fictional imports** in their `.tea.rs` templates to reference command helpers:

```rust
// In app.tea.rs
use saucer_core::Cmd;
use saucer_core::command::shutdown;
use saucer_time_manager::command::notify_after;
use saucer_http_manager::command::get;
```

**These imports don't exist!** They're fictional markers that tell the build system:
- Which managers this app uses
- Which helpers to generate
- How to transform the template code

**Build transformation:**
```rust
// Template (fictional):
use saucer_time_manager::command::notify_after;

// Transforms to (generated runtime):
use super::super::saucer_time_manager::notify_after;
```

Where `super::super::saucer_time_manager` is the generated module containing wrapped helpers.

---

## 5. The `map` Method

### Why Map?

Apps often need to transform effect results before they become messages. The `.map()` method provides a functional pipeline for this:

```rust
notify_after(0, Duration::from_millis(0), || chrono::Utc::now().timestamp_millis() as f64)
    .map(format_timestamp)           // f64 -> String
    .map(Msg::GotTime);              // String -> Msg

// Equivalent to:
notify_after(0, Duration::from_millis(0), || {
    let ts = chrono::Utc::now().timestamp_millis() as f64;
    let formatted = format_timestamp(ts);
    Msg::GotTime(formatted)
})
```

### How Map Works

Each manager's `Request` type implements `.map()`:

```rust
impl<Msg: 'static> TimeRequest<Msg> {
    pub fn map<Msg2>(self, f: impl Fn(Msg) -> Msg2 + Send + Sync + Clone + 'static)
        -> TimeRequest<Msg2>
    {
        let f = Arc::new(f);
        match self {
            TimeRequest::Now { returns } => TimeRequest::Now {
                returns: Arc::new(move |ts| f(returns(ts))),
                //                           ^^^^^^^^^^^^^^^ compose new function
            },
            TimeRequest::NotifyAfter { id, duration, returns } => TimeRequest::NotifyAfter {
                id,
                duration,
                returns: Arc::new(move || f(returns())),
            },
            // ... other variants
        }
    }
}
```

**Key mechanism:**
- Creates a new callback that composes the original callback with the mapping function
- `f(returns(result))` - first invoke original callback, then apply mapping function
- Returns a new `TimeRequest<Msg2>` with different message type
- No execution happens - just building a function composition

### Map on Cmd

The generated `Cmd` type also implements `.map()` for transforming entire command batches:

```rust
pub trait CmdExt<Msg> {
    fn map<Msg2>(self, f: impl Fn(Msg) -> Msg2 + Send + Sync + Clone + 'static)
        -> Cmd<Msg2>;
}

impl<Msg: 'static> CmdExt<Msg> for Cmd<Msg> {
    fn map<Msg2>(self, f: impl Fn(Msg) -> Msg2 + Send + Sync + Clone + 'static)
        -> Cmd<Msg2>
    {
        saucer_core::CoreCmd(
            self.into_inner()
                .into_iter()
                .map(|req| req.map(f.clone()))  // Map each request
                .collect()
        )
    }
}
```

**Use case - wrapper apps:**
```rust
// In a wrapper app that embeds an inner app:
pub enum Msg {
    Inner(inner_app::Msg),
    Widget(widget::Msg),
}

pub fn update(model: Model, msg: Msg) -> (Model, Cmd<Msg>) {
    match msg {
        Msg::Inner(inner_msg) => {
            let (inner_model, inner_cmd) = inner_app::update(model.inner, inner_msg);
            let model = Model { inner: inner_model };
            (model, inner_cmd.map(Msg::Inner))  // Transform all inner commands
        }
        // ...
    }
}
```

---

## 6. App Usage Patterns

### Basic Command

```rust
pub fn update(model: Model, msg: Msg) -> (Model, Cmd<Msg>) {
    match msg {
        Msg::StartTimer => {
            let cmd = notify_after(1, Duration::from_secs(5), || Msg::TimerExpired);
            (model, cmd)
        }
        Msg::TimerExpired => {
            (model, Cmd::none())
        }
    }
}
```

### Command with Result Transformation

```rust
pub fn update(model: Model, msg: Msg) -> (Model, Cmd<Msg>) {
    match msg {
        Msg::FetchData => {
            let cmd = get("https://api.example.com/data", |result| {
                match result {
                    Ok(response) => Msg::GotData(String::from_utf8_lossy(&response.body).to_string()),
                    Err(error) => Msg::FetchFailed(error.message),
                }
            });
            (model, cmd)
        }
        // ...
    }
}
```

### Batching Commands

```rust
pub fn init() -> (Model, Cmd<Msg>) {
    let model = Model::default();

    let cmd = Cmd::batch([
        time_now(|ts| Msg::GotInitialTime(ts)),
        get("https://api.example.com/config", |r| Msg::GotConfig(r)),
        notify_after(1, Duration::from_secs(1), || Msg::Tick),
    ]);

    (model, cmd)
}
```

### Pipeline with Map

```rust
fn format_timestamp(ts: f64) -> String {
    DateTime::<Utc>::from_timestamp(ts as i64, 0)
        .map(|dt| dt.format("%Y-%m-%d %H:%M:%S UTC").to_string())
        .unwrap_or_else(|| format!("invalid timestamp: {}", ts))
}

pub fn init() -> (Model, Cmd<Msg>) {
    let cmd = time_now(|ts| ts)           // Get raw timestamp
        .map(format_timestamp)             // Transform to string
        .map(Msg::GotTime);                // Wrap in Msg

    (Model::default(), cmd)
}
```

---

## 7. Effect Manager Perspective

### Defining Request Types

Effect managers define their request enums with `returns` callbacks:

```rust
// In my_manager/src/requests.rs
use std::sync::Arc;

#[derive(Clone)]
pub enum MyRequest<Msg> {
    // Request with no return value (fire-and-forget)
    DoSomething {
        param: String,
        returns: Arc<dyn Fn() -> Msg + Send + Sync>,
    },

    // Request with return value
    FetchSomething {
        id: u64,
        returns: Arc<dyn Fn(Result<Data, Error>) -> Msg + Send + Sync>,
    },
}
```

**Guidelines:**
- Use `Arc<dyn Fn(...) -> Msg>` for callbacks (allows cloning)
- Add `Send + Sync` bounds (callbacks cross thread boundaries)
- Return type of callback matches what the effect produces
- Use `Result<T, E>` for fallible operations

### Providing Request Helpers

```rust
// In my_manager/src/requests.rs

pub fn do_something<Msg: 'static>(
    param: impl Into<String>,
    returns: impl Fn() -> Msg + Send + Sync + 'static,
) -> MyRequest<Msg> {
    MyRequest::DoSomething {
        param: param.into(),
        returns: Arc::new(returns),
    }
}

pub fn fetch_something<Msg: 'static>(
    id: u64,
    returns: impl Fn(Result<Data, Error>) -> Msg + Send + Sync + 'static,
) -> MyRequest<Msg> {
    MyRequest::FetchSomething {
        id,
        returns: Arc::new(returns),
    }
}
```

**Best practices:**
- Name helpers after the action (imperative: `get`, `notify_after`, `subscribe`)
- Use `impl Into<T>` for string/collection parameters
- Use `impl Fn(...)` for callbacks (more flexible than `Arc<dyn Fn>`)
- Helper constructs the request with `Arc::new(returns)` to wrap the callback

### Implementing Map

```rust
impl<Msg: 'static> MyRequest<Msg> {
    pub fn map<Msg2>(self, f: impl Fn(Msg) -> Msg2 + Send + Sync + Clone + 'static)
        -> MyRequest<Msg2>
    {
        let f = Arc::new(f);
        match self {
            MyRequest::DoSomething { param, returns } => MyRequest::DoSomething {
                param,
                returns: Arc::new(move || f(returns())),
            },
            MyRequest::FetchSomething { id, returns } => MyRequest::FetchSomething {
                id,
                returns: Arc::new(move |result| f(returns(result))),
            },
        }
    }
}
```

**Pattern:**
- `Arc::new(f)` to make the mapping function cloneable
- For each variant, compose `f(returns(...))` in a new callback
- Preserve all other fields unchanged

### Executing Requests

```rust
// In my_manager/src/lib.rs
impl MyManager {
    pub fn on_effects<Msg: 'static>(
        &self,
        router: &Router<Msg, ()>,
        state: (),
        effects: Vec<MyRequest<Msg>>,
    ) -> () {
        for request in effects {
            match request {
                MyRequest::DoSomething { param, returns } => {
                    // Execute the effect
                    do_the_thing(&param);

                    // Invoke the callback to get the Msg
                    let msg = returns();

                    // Send to app
                    router.send_to_app(msg);
                }
                MyRequest::FetchSomething { id, returns } => {
                    let router = router.clone();
                    tokio::spawn(async move {
                        // Execute async effect
                        let result = fetch_data(id).await;

                        // Invoke callback with result
                        let msg = returns(result);

                        // Send to app
                        router.send_to_app(msg);
                    });
                }
            }
        }
    }
}
```

**Key points:**
- Extract `returns` callback from request
- Execute the effect (sync or async)
- Invoke `returns(result)` to get the `Msg`
- Send to app via `router.send_to_app(msg)`

---

## 8. Build System Integration

### Template Discovery

The build system:

1. **Scans for fictional imports** in `.tea.rs` files:
   ```rust
   use saucer_time_manager::command::notify_after;
   ```

2. **Tracks which helpers are used** across all templates

3. **Generates wrapped helpers** only for used helpers (dead code elimination)

### Generated Runtime Structure

```rust
// Generated in OUT_DIR/runtime.rs

// Request enum combining all managers
pub enum Request<Msg> {
    Core(saucer_core::CoreRequest),
    Time(saucer_time_manager::TimeRequest<Msg>),
    Http(saucer_http_manager::HttpRequest<Msg>),
}

// Cmd type alias
pub type Cmd<Msg> = saucer_core::CoreCmd<Request<Msg>>;

// Command helper modules
pub mod core {
    pub fn shutdown<Msg>() -> Cmd<Msg> { ... }
}

pub mod saucer_time_manager {
    pub fn notify_after<Msg>(...) -> Cmd<Msg> { ... }
    pub fn time_now<Msg>(...) -> Cmd<Msg> { ... }
}

pub mod saucer_http_manager {
    pub fn get<Msg>(...) -> Cmd<Msg> { ... }
}

// Transformed template modules
pub mod my_app {
    pub mod app {
        // Transformed .tea.rs code with fictional imports replaced
    }
}
```

### Template Transformation

```rust
// Original .tea.rs (fictional imports)
use saucer_core::Cmd;
use saucer_time_manager::command::notify_after;

pub fn init() -> (Model, Cmd<Msg>) {
    let cmd = notify_after(0, Duration::from_secs(1), || Msg::Tick);
    (Model::default(), cmd)
}

// Transformed (in generated runtime)
use super::super::Cmd;                         // Points to generated Cmd type
use super::super::saucer_time_manager::notify_after;  // Points to generated helper

pub fn init() -> (Model, Cmd<Msg>) {
    let cmd = notify_after(0, Duration::from_secs(1), || Msg::Tick);
    (Model::default(), cmd)
}
```

**Transformation rules:**
- `saucer_core::Cmd` → `super::super::Cmd`
- `<manager>::command::<helper>` → `super::super::<manager>::<helper>`
- `saucer_core::command::<helper>` → `super::super::core::<helper>`

---

## 9. Design Principles

### Commands Are Pure Data

Commands don't execute anything - they're declarative descriptions:

```rust
// ✅ This is data - no side effects
let cmd = get("https://api.example.com/data", Msg::GotData);

// ❌ This would be impure - don't do this!
let response = blocking_http_get("https://api.example.com/data");
let msg = Msg::GotData(response);
```

### Separation of Description and Execution

- **Apps describe** what effects to request (via commands)
- **Managers execute** how to perform effects (via `on_effects`)
- **Runtime coordinates** dispatching commands to managers and routing results back

### Type Safety Throughout

The `Msg` type parameter flows through the entire chain:

```
App's Msg → Cmd<Msg> → Request<Msg> → ManagerRequest<Msg> → returns: Fn(...) -> Msg
```

This ensures:
- Callbacks always produce the correct message type
- No runtime casting or type erasure
- Compile-time verification of effect → message flow

### Payload Hiding

Apps use helpers, not raw requests:

```rust
// ✅ App perspective (ergonomic helper)
notify_after(0, Duration::from_secs(5), || Msg::Tick)

// ❌ Not this (internal plumbing)
Cmd::single(Request::Time(TimeRequest::NotifyAfter {
    id: 0,
    duration: Duration::from_secs(5),
    returns: Arc::new(|| Msg::Tick),
}))
```

Benefits:
- Cleaner app code
- Helpers can provide validation, defaults, conveniences
- Internal request structure can evolve without breaking apps

---

## 10. Common Patterns

### Conditional Commands

```rust
pub fn update(model: Model, msg: Msg) -> (Model, Cmd<Msg>) {
    match msg {
        Msg::Toggle => {
            let model = Model { enabled: !model.enabled };
            let cmd = if model.enabled {
                notify_after(1, Duration::from_secs(1), || Msg::Tick)
            } else {
                Cmd::none()
            };
            (model, cmd)
        }
    }
}
```

### Command Builder Pattern

```rust
fn build_startup_commands(config: &Config) -> Cmd<Msg> {
    let mut cmds = vec![];

    if config.fetch_on_start {
        cmds.push(get(config.api_url.clone(), Msg::GotInitialData));
    }

    if config.enable_timer {
        cmds.push(notify_after(1, config.interval, || Msg::Tick));
    }

    Cmd::batch(cmds)
}
```

### Effect Chaining via Messages

Commands don't chain directly - chain via messages:

```rust
pub fn update(model: Model, msg: Msg) -> (Model, Cmd<Msg>) {
    match msg {
        Msg::Start => {
            // First effect
            (model, get("/api/config", Msg::GotConfig))
        }
        Msg::GotConfig(config) => {
            // Second effect, triggered by first's completion
            let model = Model { config: Some(config.clone()) };
            (model, get(&config.data_url, Msg::GotData))
        }
        Msg::GotData(data) => {
            // Final state
            (Model { data: Some(data) }, Cmd::none())
        }
    }
}
```

---

## 11. References

- **[Main README](../../README.md)** - Saucer overview and quick start
- **[Effect Managers](./effect-managers.md)** - How to implement effect managers
- **[Observability](./observability.md)** - How to observe commands and effects
- **[Ports](./ports.md)** - Bidirectional communication with external code
- **Examples**: See [mock_app/src/app.tea.rs](../../saucer-core/tests/mock_app/src/app.tea.rs)
