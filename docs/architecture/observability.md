# Observability Architecture

**Feature**: Pluggable observer functions for automatic event/effect/self-msg logging
**Status**: Implemented (channel-backed async runtime)

---

## Overview

The observability system allows programs to capture all events and effects passing through the system without manual trace statements. Observer functions are plugged into the `Runtime` and receive typed observations with timestamps.

---

## Core Types

### Observation

```rust
pub enum Observation<EventType, CommandType, SelfMsgType> {
    Event {
        ts: SystemTime,
        data: EventType,
    },
    Effect {
        ts: SystemTime,
        data: CommandType,
    },
    ManagerMsg {
        ts: SystemTime,
        manager: &'static str,
        data: SelfMsgType,
    },
}
```

**Properties**:
- Contains actual typed data (not pre-serialized)
- Timestamp captured at single ordered point in runtime
- Observers decide serialization format
- Manager self-messages (`router.send_to_self`) flow through observers
- `SelfMsgType` is the unified self-message enum generated by the build system

### ObserverFn

```rust
pub type ObserverFn<EventType, CommandType, SelfMsgType> =
    Arc<dyn Fn(&Observation<EventType, CommandType, SelfMsgType>) + Send + Sync>;
```

Arc'd trait object that receives observations. Uses trait objects (not function pointers) to support factory functions that capture state (e.g., file handles in `jsonl_observer`). Arc allows cloning the observer for concurrent access.

---

## Architecture Flow

```
Event arrives
     ↓
process_event() creates Observation::Event
     ↓
Calls observer(&observation)
     ↓
Observer serializes/logs (or no-op)
     ↓
Continue with event processing
```

```
Commands dispatched
     ↓
dispatch_commands() creates Observation::Effect
     ↓
Calls observer(&observation)
     ↓
Observer serializes/logs (or no-op)
     ↓
Send effects to managers
```

**Key Points**:
- Synchronous calls (preserves ordering)
- Timestamp captured in runtime (single source of truth)
- Observer receives typed data (decides format)

### Manager Self-Messages

```
Manager spawns async work
     ↓
Background work calls router.send_to_self()
     ↓
Router emits Observation::ManagerMsg
     ↓
Manager task receives self-message
```

- Allows observing internal manager chatter (e.g., SDK events, retries)
- Observation payload contains manager name + `Debug` representation of the message

---

## Observer Implementations

### no_op_observer

```rust
pub fn no_op_observer<EventType, CommandType, SelfMsgType>() -> ObserverFn<EventType, CommandType, SelfMsgType>
where
    EventType: 'static,
    CommandType: 'static,
    SelfMsgType: 'static,
{
    Arc::new(|_observation: &Observation<EventType, CommandType, SelfMsgType>| {
        // Empty - no overhead
    })
}
```

**Performance**: Minimal overhead (empty closure)
**Use case**: Disable observability

### tracing_observer (default)

```rust
pub fn tracing_observer<EventType, CommandType, SelfMsgType>() -> ObserverFn<EventType, CommandType, SelfMsgType>
where
    EventType: Debug + 'static,
    CommandType: Debug + 'static,
    SelfMsgType: Debug + 'static,
{
    Arc::new(|observation: &Observation<EventType, CommandType, SelfMsgType>| {
        match observation {
            Observation::Event { data, .. } => {
                tracing::info!(target: "saucer-core::Msg", "Msg({:?})", data);
            }
            Observation::Effect { data, .. } => {
                tracing::debug!(target: "saucer-core::Cmd", "Cmd({:?})", data);
            }
            Observation::ManagerMsg { manager, data, .. } => {
                tracing::debug!(target: "saucer-core::SelfMsg", "SelfMsg({:?}, {:?})", manager, data);
            }
        }
    })
}
```

**Performance**: Depends on tracing subscriber configuration
**Default behavior**: Common choice for applications
**Use case**: Standard logging via tracing ecosystem

### jsonl_observer

```rust
pub fn jsonl_observer<EventType, CommandType, SelfMsgType, P>(log_dir: P) -> ObserverFn<EventType, CommandType, SelfMsgType>
where
    EventType: Serialize + 'static,
    CommandType: Serialize + 'static,
    SelfMsgType: Serialize + 'static,
    P: AsRef<Path>,
{
    // Returns closure that writes JSONL to log_dir/events.jsonl
}
```

**Output Format**: JSONL (JSON Lines)
- One JSON object per line
- Fields: `type`, `ts`, `data`
- Example:
  ```jsonl
  {"type":"event","ts":1730908335.123456789,"data":{"UserClicked":{"button_id":"submit"}}}
  {"type":"effect","ts":1730908335.124567890,"data":{"Http":{"url":"https://api.example.com"}}}
  {"type":"manager_msg","ts":1730908335.125,"manager":"Http","data":{"ResponseReceived":{"status":200}}}
  ```

**Timestamp Format**: `f64` (seconds since UNIX_EPOCH with fractional nanoseconds)

**File Management**:
- Creates log_dir if doesn't exist
- Appends to `events.jsonl`
- Uses `BufWriter` (64 KiB buffer)
- Explicit flush for safety

**Use case**: Event replay, offline analysis

### filter_observer

```rust
pub fn filter_observer<EventType, CommandType, SelfMsgType>(
    wrapped: ObserverFn<EventType, CommandType, SelfMsgType>,
    include_events: bool,
    include_manager_msgs: bool,
    include_effects: bool,
) -> ObserverFn<EventType, CommandType, SelfMsgType>
```

**Simple filtering** by observation type (events, effects, manager messages).

**Use case**: Only log certain observation types

### filter_with

```rust
pub fn filter_with<EventType, CommandType, SelfMsgType, F>(
    wrapped: ObserverFn<EventType, CommandType, SelfMsgType>,
    predicate: F,
) -> ObserverFn<EventType, CommandType, SelfMsgType>
where
    F: Fn(&Observation<EventType, CommandType, SelfMsgType>) -> bool + Send + Sync + 'static
```

**Predicate filtering** using the actual generated types, e.g. keep only `Observation::Event { .. }`.

### Custom Filter with Generated Types

The real power of observers is that they're created in your `main.rs` **after code generation**, giving you access to the concrete generated types:

```rust
// In main.rs - after runtime generation
mod runtime {
    include!(concat!(env!("OUT_DIR"), "/runtime.rs"));
}

use runtime::sync::Runtime;
use runtime::{Request, SelfMsg};
use runtime::my_app::app::{self, Msg};  // Adjust path based on your crate/module
use saucer_core::{tee_observer, Observation};
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // Custom filter that inspects generated types
    let custom_observer = tee_observer(vec![
        // Only log HTTP requests
        Arc::new(|obs: &Observation<Msg, Request<Msg>, SelfMsg>| {
            if let Observation::Effect { data, .. } = obs {
                if let Request::Http(_) = data {
                    tracing::info!("HTTP request: {:?}", data);
                }
            }
        }),

        // Only log specific message types
        Arc::new(|obs: &Observation<Msg, Request<Msg>, SelfMsg>| {
            if let Observation::Event { data, .. } = obs {
                if matches!(data, Msg::GotData(_) | Msg::Error(_)) {
                    tracing::warn!("Important message: {:?}", data);
                }
            }
        }),
    ]);

    Runtime::new(
        app::init,
        app::update,
        app::view,
        saucer_core::no_op_reconciler(),
        custom_observer,  // Use custom filtered observer
    )
    .run()
    .await;
}
```

**Key insight**: The closure has access to the **actual generated types** (`Msg`, `Request<Msg>`, `SelfMsg`), enabling type-safe pattern matching on your application's concrete types.

**Why this works**:
- Generic observer functions (`tracing_observer`, `filter_observer`) work with any types
- Your `main.rs` creates observers **after** code generation completes
- Closures capture the concrete types from the generated `runtime` module
- You can pattern match on actual enum variants to filter precisely
- The `Request` enum has variants for each effect manager (e.g., `Request::Http`, `Request::Time`)
- The `Msg` enum is your application's message type from your `.tea.rs` template

### tee_observer

```rust
pub fn tee_observer<EventType, CommandType, SelfMsgType>(
    observers: Vec<ObserverFn<EventType, CommandType, SelfMsgType>>,
) -> ObserverFn<EventType, CommandType, SelfMsgType>
where
    EventType: 'static,
    CommandType: 'static,
    SelfMsgType: 'static,
{
    Arc::new(move |observation| {
        for observer in &observers {
            observer(observation);
        }
    })
}
```

**Performance**: Sum of all observers
**Use case**: Combine multiple observers (e.g., tracing + JSONL + custom filters)

---

## Runtime Integration

### Adding Observer to Runtime

```rust
// Default: Uses tracing_observer()
Runtime::new(
    app::init,
    app::update,
    app::view,
    saucer_core::no_op_reconciler(),
    saucer_core::tracing_observer(),  // Default observer
)

// With JSONL logging
Runtime::new(
    app::init,
    app::update,
    app::view,
    saucer_core::no_op_reconciler(),
    saucer_core::jsonl_observer("logs/myapp"),
)

// With multiple observers
Runtime::new(
    app::init,
    app::update,
    app::view,
    saucer_core::no_op_reconciler(),
    saucer_core::tee_observer(vec![
        saucer_core::tracing_observer(),
        saucer_core::jsonl_observer("logs/myapp"),
    ]),
)

// No observability
Runtime::new(
    app::init,
    app::update,
    app::view,
    saucer_core::no_op_reconciler(),
    saucer_core::no_op_observer(),
)
```

### Runtime Implementation

The Runtime uses the observer internally:

```rust
pub struct Runtime<Msg> {
    observer: ObserverFn<Msg, Request<Msg>, SelfMsg>,
    // ... other fields
}

impl<Msg> Runtime<Msg> {
    fn process_msg(&mut self, msg: Msg) {
        // Observe message
        let observation = Observation::Event {
            ts: SystemTime::now(),
            data: msg.clone(),
        };
        (self.observer)(&observation);

        // Continue with message processing...
    }

    fn dispatch_commands(&mut self, commands: Cmd<Msg>) {
        for request in commands.into_inner() {
            // Observe effect
            let observation = Observation::Effect {
                ts: SystemTime::now(),
                data: request.clone(),
            };
            (self.observer)(&observation);

            // Dispatch to manager...
        }
    }
}
```

---

## Performance Considerations

### no_op_observer
- **Overhead**: Minimal (empty closure, may be optimized away)
- **Use case**: Disable observability

### tracing_observer
- **Overhead**: Depends on tracing subscriber configuration
- **Typical**: <1% with production subscriber
- **Use case**: Production default (standard logging)

### jsonl_observer
- **Overhead**: ~5% under normal load
- **Breakdown**:
  - `SystemTime::now()`: ~50-100 ns
  - JSON serialization: ~1-10 μs
  - Buffered file write: ~100-500 ns (amortized)
- **Use case**: Development, debugging, event replay

---

## Custom Observers

Users can implement custom observers:

```rust
fn metrics_observer<EventType, CommandType, SelfMsgType>(
    observation: &Observation<EventType, CommandType, SelfMsgType>
) {
    match observation {
        Observation::Event { ts, data } => {
            // Count events, track timing, etc.
        }
        Observation::Effect { ts, data } => {
            // Count effects by type
        }
        Observation::ManagerMsg { ts, manager, data } => {
            // Track manager activity
        }
    }
}
```

Observers can:
- Filter by type
- Add sequence numbers
- Send to network
- Aggregate metrics
- Write different formats (MessagePack, CSV)

---

## Design Decisions

### Why Trait Objects (Arc<dyn Fn>)?
- Supports factory functions that capture state (file handles, counters, etc.)
- Allows observers to return closures from initializers
- Arc enables cloning for concurrent access across runtime components
- Small heap allocation (one Arc per program, not per observation)
- Simple runtime integration
- More flexible than raw function pointers

### Why Typed Data?
- Observer decides serialization format
- Supports multiple formats (JSON, MessagePack, CSV)
- No premature optimization (serialize only if needed)

### Why No Sequence Numbers?
- Events/effects already ordered (single-threaded)
- Timestamps sufficient for ordering
- Observers can add if needed

### Why Synchronous Calls?
- Preserves ordering guarantees
- Simpler implementation
- Overhead is acceptable (<5%)
- Async would complicate macro

---

## Replay and Effect Serialization

### Events Are Replayable, Effects Are Not

Following Elm's time-travel debugger model:

**Events should be replayed:**
- Events are the inputs to `update()`
- Replaying events recreates application state
- Events fully serialize (they're data)

**Effects should NOT be replayed:**
- Effects are outputs of `update()`
- Effects are re-generated during replay
- Effects may contain non-serializable data

### Why Effects Can't Fully Serialize

Effects contain **callbacks** (closures) that route manager results back to the app:

```rust
pub struct TimeRequest<Msg> {
    pub duration: Duration,
    pub returns: Arc<dyn Fn() -> Msg + Send + Sync>,  // ← Closure!
}
```

**Function pointers cannot be serialized.** For observability:
- `returns` callback serializes as `"<function>"`
- Duration, URLs, etc. serialize normally
- This is sufficient for debugging (see what was requested)
- Not sufficient for replay (can't recreate the closure)

### Replay Flow

```
1. Log all events (fully serializable)
2. Replay: init() → event1 → event2 → event3
3. Each update() re-generates effects
4. Effects execute, producing new events
5. New events also replayed
```

**Example:**
```
Recorded log:
  Event: ButtonClicked
  Effect: TimeRequest { duration: 1s, returns: <function> }  ← observed but not replayed
  Event: TimerElapsed { duration: 1s }  ← replayed

Replay:
  1. Replay: ButtonClicked → generates TimeRequest
  2. Timer executes → produces TimerElapsed event
  3. Replay: TimerElapsed → continues
```

### Use Cases

**Observing Effects (this feature):**
- See what side effects were requested
- Debug: "Did we send that HTTP request?"
- Monitor: "How many timers are active?"
- Format: JSONL with partial serialization

**Replaying Events (future feature):**
- Recreate application state
- Time-travel debugging
- Requires: Event log only
- Format: Events must fully serialize

---

## Testing Strategy

### Integration Tests
- Verify observer called for events
- Verify observer called for effects
- Verify ordering preserved
- Verify timestamps accurate

### Performance Tests
- Benchmark no_op_observer (should be zero)
- Benchmark standard_observer (<5% overhead)
- Measure under load (1000+ events/sec)

### Example Apps
- `examples/observability/no_op/` - Default behavior
- `examples/observability/standard/` - JSONL logging

---

## Future Extensions

Potential enhancements (out of scope):

- **Filtering observers**: Only log certain event types
- **Sampling observers**: Probabilistic logging
- **Network observers**: Send to remote collector
- **Metrics observers**: Aggregate statistics
- **Composite observers**: Chain multiple observers
- **Async observers**: Non-blocking writes

All would use the same `Observation<EventType, CommandType, SelfMsgType>` type.
